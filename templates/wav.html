<!DOCTYPE html>
<html lang="ja">

<head>
  <title>Save audio data</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='bootstrap/css/bootstrap.min.css') }}">
  <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">

</head>

<body>
  <a id="download">Download</a>
  <button id="stop">Stop</button>
  <button id="start">Start</button>
  <button id="send2" href="{{url_for('score')}}">Send2</button>
  <button id="send3" href="{{url_for('score')}}">Send3</button>

  <script>
    // for html
    const downloadLink = document.getElementById('download');
    const stopButton = document.getElementById('stop');
    const startButton = document.getElementById('start')
    const sendButton2 = document.getElementById('send2')
    const sendButton3 = document.getElementById('send3')
    const _sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    // for audio
    let audio_sample_rate = null;
    let scriptProcessor = null;
    let audioContext = null;

    // audio data
    let audioData = [];
    let bufferSize = 1024;

    // SendButton3 JsonのテキストをPOST送信
    // 受け側は”data = request.form.get('data')”
    sendButton3.addEventListener('click', function (event) {
      var data = { 'data': 'Hello, Flask3!' };

      var xhr = new XMLHttpRequest();
      xhr.open('POST', sendButton3.getAttribute('href'), true);
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      xhr.onreadystatechange = function () {
        if (this.readyState === XMLHttpRequest.DONE && this.status === 200) {
          console.log('データを送信しました。');
        }
      };
      xhr.send('data=' + JSON.stringify(data));
//      window.location.href = sendButton3.getAttribute('href');
    });

    sendButton2.addEventListener('click', function (event) {

      var audioBlob = exportWAV2(audioData);
    
      console.log("wavedata")
      console.log(audioBlob)
//      console.log(wavdata);
      var xhr = new XMLHttpRequest();
      xhr.open('POST', sendButton2.getAttribute('href'), true);
      xhr.setRequestHeader('Content-Type', 'application/octet-stream');
      xhr.onload  = function () {
        if (xhr.status === 200) {
          console.log('Upload successful');
        } else {
          console.log('Upload failed');
      }
      };
      xhr.send(audioBlob);
      window.location.href = sendButton2.getAttribute('href');
    });


    // export WAV from audio float data
    let exportWAV2 = function (audioData) {
      console.log('function_exportWAV2')
      let encodeWAV = function (samples, sampleRate) {
        let buffer = new ArrayBuffer(44 + samples.length * 2);
        let view = new DataView(buffer);

        let writeString = function (view, offset, string) {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        };

        let floatTo16BitPCM = function (output, offset, input) {
          for (let i = 0; i < input.length; i++, offset += 2) {
            let s = Math.max(-1, Math.min(1, input[i]));
            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
          }
        };

        writeString(view, 0, 'RIFF');  // RIFFヘッダ
        view.setUint32(4, 32 + samples.length * 2, true); // これ以降のファイルサイズ
        writeString(view, 8, 'WAVE'); // WAVEヘッダ
        writeString(view, 12, 'fmt '); // fmtチャンク
        view.setUint32(16, 16, true); // fmtチャンクのバイト数
        view.setUint16(20, 1, true); // フォーマットID
        view.setUint16(22, 1, true); // チャンネル数
        view.setUint32(24, sampleRate, true); // サンプリングレート
        view.setUint32(28, sampleRate * 2, true); // データ速度
        view.setUint16(32, 2, true); // ブロックサイズ
        view.setUint16(34, 16, true); // サンプルあたりのビット数
        writeString(view, 36, 'data'); // dataチャンク
        view.setUint32(40, samples.length * 2, true); // 波形データのバイト数
        floatTo16BitPCM(view, 44, samples); // 波形データ

        return view;
      };

      let mergeBuffers = function (audioData) {
        console.log('function_mergeBuffers')
        let sampleLength = 0;
        for (let i = 0; i < audioData.length; i++) {
          sampleLength += audioData[i].length;
        }
        let samples = new Float32Array(sampleLength);
        let sampleIdx = 0;
        for (let i = 0; i < audioData.length; i++) {
          for (let j = 0; j < audioData[i].length; j++) {
            samples[sampleIdx] = audioData[i][j];
            sampleIdx++;
          }
        }
        return samples;
      };

      let dataview = encodeWAV(mergeBuffers(audioData), audio_sample_rate);
      let audioBlob = new Blob([dataview], { type: 'audio/wav' });
      console.log("DataView:")
      console.log(dataview);
      let myURL = window.URL || window.webkitURL;
      let url = myURL.createObjectURL(audioBlob);
      console.log("URL:")
      console.log(url)

      return audioBlob;
    };

    let saveAudio = function () {
      console.log('function_saveAudio')
      downloadLink.href = exportWAV(audioData);
      downloadLink.download = 'test.wav';
      //      downloadLink.click();

      audioContext.close().then(function () {
        stopButton.setAttribute('disabled', 'disabled');
      });
    };

    // export WAV from audio float data
    let exportWAV = function (audioData) {
      console.log('function_exportWAV')
      let encodeWAV = function (samples, sampleRate) {
        let buffer = new ArrayBuffer(44 + samples.length * 2);
        let view = new DataView(buffer);

        let writeString = function (view, offset, string) {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        };

        let floatTo16BitPCM = function (output, offset, input) {
          for (let i = 0; i < input.length; i++, offset += 2) {
            let s = Math.max(-1, Math.min(1, input[i]));
            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
          }
        };

        writeString(view, 0, 'RIFF');  // RIFFヘッダ
        view.setUint32(4, 32 + samples.length * 2, true); // これ以降のファイルサイズ
        writeString(view, 8, 'WAVE'); // WAVEヘッダ
        writeString(view, 12, 'fmt '); // fmtチャンク
        view.setUint32(16, 16, true); // fmtチャンクのバイト数
        view.setUint16(20, 1, true); // フォーマットID
        view.setUint16(22, 1, true); // チャンネル数
        view.setUint32(24, sampleRate, true); // サンプリングレート
        view.setUint32(28, sampleRate * 2, true); // データ速度
        view.setUint16(32, 2, true); // ブロックサイズ
        view.setUint16(34, 16, true); // サンプルあたりのビット数
        writeString(view, 36, 'data'); // dataチャンク
        view.setUint32(40, samples.length * 2, true); // 波形データのバイト数
        floatTo16BitPCM(view, 44, samples); // 波形データ

        return view;
      };

      let mergeBuffers = function (audioData) {
        console.log('function_mergeBuffers')
        let sampleLength = 0;
        for (let i = 0; i < audioData.length; i++) {
          sampleLength += audioData[i].length;
        }
        let samples = new Float32Array(sampleLength);
        let sampleIdx = 0;
        for (let i = 0; i < audioData.length; i++) {
          for (let j = 0; j < audioData[i].length; j++) {
            samples[sampleIdx] = audioData[i][j];
            sampleIdx++;
          }
        }
        return samples;
      };

      let dataview = encodeWAV(mergeBuffers(audioData), audio_sample_rate);
      let audioBlob = new Blob([dataview], { type: 'audio/wav' });
      console.log("DataView:")
      console.log(dataview);

      let myURL = window.URL || window.webkitURL;
      let url = myURL.createObjectURL(audioBlob);
      console.log("URL:")
      console.log(url)
      return url;
    };

    // stop button
    stopButton.addEventListener('click', function () {
      saveAudio();
      console.log('saved wav');
    });

    // save audio data
    var onAudioProcess = function (e) {
      var input = e.inputBuffer.getChannelData(0);
      var bufferData = new Float32Array(bufferSize);
      for (var i = 0; i < bufferSize; i++) {
        bufferData[i] = input[i];
      }

      audioData.push(bufferData);
    };

    // getusermedia
    let handleSuccess = function (stream) {
      console.log('function_handleSuccess')
      audioContext = new AudioContext();
      audio_sample_rate = audioContext.sampleRate;
      console.log(audio_sample_rate);
      scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
      var mediastreamsource = audioContext.createMediaStreamSource(stream);
      mediastreamsource.connect(scriptProcessor);
      scriptProcessor.onaudioprocess = onAudioProcess;
      scriptProcessor.connect(audioContext.destination);

      console.log('record start?');

      // when time passed without pushing the stop button
      setTimeout(function () {
        console.log("10 sec");
        if (stopButton.disabled == false) {
          saveAudio();
          console.log("saved audio");
        }
      }, 10000);
    };

    // start button
    startButton.addEventListener('click', function () {
      navigator.mediaDevices.getUserMedia({ audio: true, video: false })
        .then(handleSuccess);

      console.log('Start Button');
    });


    // getUserMedia
    //navigator.mediaDevices.getUserMedia({ audio: true, video: false })
    //  .then(handleSuccess);

  </script>
</body>

</html>